# --- START OF FILE subtitle_app.py ---

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox, colorchooser
import threading
import queue
import os
import re
import datetime
import whisper
import moviepy.editor as mp
import torch
import json
import asyncio
import time
import traceback
import atexit # For cleanup
import sys # For restart functionality
from string import Template

# --- API 相关导入 ---
try:
    from openai import (
        AsyncOpenAI,
        APIError,
        AuthenticationError,
        RateLimitError,
        APIConnectionError,
        APITimeoutError,
        InternalServerError
    )
    # 使用 json_repair 尝试修复不规范的 JSON 输出
    from json_repair import repair_json # 保留
    openai_available = True
except ImportError:
    openai_available = False
    print("警告: `openai` 或 `json_repair` 库未安装或版本过低。将无法使用 API 功能。")
    print("请运行: pip install --upgrade openai json_repair")
    # Define dummy exceptions if openai is not available to avoid NameErrors later
    class APIError(Exception): pass
    class AuthenticationError(APIError): pass
    class RateLimitError(APIError): pass
    class APIConnectionError(APIError): pass
    class APITimeoutError(APIError): pass
    class InternalServerError(APIError): pass


try:
    from ttkthemes import ThemedTk
    use_themes = True
except ImportError:
    use_themes = False

# --- 常量 ---
# Default values, will be potentially overridden by config
DEFAULT_API_BASE = "https://api.deepseek.com/v1"
DEFAULT_API_MODEL = "deepseek-chat"
# Default Concurrency
DEFAULT_MAX_CONCURRENT_REQUESTS = 15

# --- Global list for temporary files ---
TEMP_FILES_TO_CLEAN = [] # Although not used in the fixed thread, keep for atexit just in case

# --- atexit cleanup function ---
def cleanup_temp_files():
    print("\n程序退出：正在清理临时文件...")
    cleaned_count = 0
    # Iterate over a copy in case the list gets modified elsewhere unexpectedly
    files_to_check = list(TEMP_FILES_TO_CLEAN)
    TEMP_FILES_TO_CLEAN.clear() # Clear original list immediately

    for temp_file in files_to_check:
        try:
            if os.path.exists(temp_file):
                os.remove(temp_file)
                print(f"  - 已删除: {temp_file}")
                cleaned_count += 1
        except Exception as e:
            print(f"  - 删除失败: {temp_file} ({e})")
    if cleaned_count > 0:
        print(f"共清理 {cleaned_count} 个临时文件 (atexit)。")
    else:
        print("无临时文件需要清理 (atexit)。")

# Register the cleanup function
atexit.register(cleanup_temp_files)


# --- ASS Style Constants ---
# Default values, might be overridden by config
ASS_DEFAULT_STYLE_NAME = "Default"
ASS_TRANSLATED_STYLE_NAME = "TranslatedStyle"

# Default Style values (can be overridden by config)
DEFAULT_STYLE_DEFAULTS = {
    "fontname": "Arial",
    "fontsize": 20,
    "primary_colour": "&H00FFFFFF&", # White
    "secondary_colour": "&H000000FF&", # Opaque Red
    "outline_colour": "&H00000000&", # Black
    "back_colour": "&H00000000&", # Black (transparent if alpha used right)
    "bold": -1, # True
    "italic": 0,
    "underline": 0,
    "strikeout": 0,
    "scalex": 100,
    "scaley": 100,
    "spacing": 0,
    "angle": 0,
    "borderstyle": 1,
    "outline": 2,
    "shadow": 2,
    "alignment": 2, # Bottom center
    "marginl": 10,
    "marginr": 10,
    "marginv": 10,
    "encoding": 1
}
TRANSLATED_STYLE_DEFAULTS = DEFAULT_STYLE_DEFAULTS.copy()
TRANSLATED_STYLE_DEFAULTS.update({
    "fontsize": 24,
    "primary_colour": "&H0000FF00&", # Green
})

# ASS Style Format String (used in reconstruct_ass)
ASS_STYLE_FORMAT = "Style: {Name},{Fontname},{Fontsize},{PrimaryColour},{SecondaryColour},{OutlineColour},{BackColour},{Bold},{Italic},{Underline},{StrikeOut},{ScaleX},{ScaleY},{Spacing},{Angle},{BorderStyle},{Outline},{Shadow},{Alignment},{MarginL},{MarginR},{MarginV},{Encoding}"

# ASS 头部模板
ASS_HEADER_TEMPLATE = """
[Script Info]
; Script generated by Subtitle Generator App
Title: {title}
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
{styles}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

# --- Prompt 模板 (只翻译) ---
TRANSLATE_ONLY_PROMPT_TEMPLATE = Template("""
# Role: 资深翻译专家
You are a professional translator specializing in creating subtitles for Netflix. You are fluent in ${target_language}. Translate the following English subtitle sentence into ${target_language}.

# Requirements:
- Provide only the translated sentence.
- Ensure the translation is natural, accurate, and fits the context of subtitles.
- Do NOT include the original English text.
- Do NOT add any explanations, introductory phrases, or quotation marks around the translation.

# English Sentence to Translate:
"${original_text}"
""")


# --- 配置文件路径 ---
CONFIG_DIR = os.path.expanduser("~/.config/SubtitleGeneratorApp")
CONFIG_FILE = os.path.join(CONFIG_DIR, "settings.json")

# --- 配置加载/保存函数 ---
def load_config():
    """加载配置文件，如果文件不存在或无效则返回配置字典，并更新全局变量"""
    global MAX_CONCURRENT_REQUESTS, DEFAULT_API_BASE, DEFAULT_API_MODEL # Make globals modifiable

    # --- Default theme ---
    default_theme = "clam" # A generally safe and good-looking default ttk theme

    # Combine all defaults
    defaults = {
        "api_key": "",
        "api_base_url": DEFAULT_API_BASE,
        "api_model_name": DEFAULT_API_MODEL,
        "whisper_model": "base",
        "whisper_language": "en",
        "device": "自动检测",
        "enable_refinement": False,
        "target_language": "中文",
        "max_concurrent_requests": DEFAULT_MAX_CONCURRENT_REQUESTS,
        "style_default": DEFAULT_STYLE_DEFAULTS.copy(),
        "style_translated": TRANSLATED_STYLE_DEFAULTS.copy(),
        # --- 新增: Add theme to defaults ---
        "selected_theme": default_theme
    }

    config_to_return = defaults.copy()

    if not os.path.exists(CONFIG_FILE):
        print(f"配置文件未找到，使用默认设置 (包括主题: {default_theme})。")
        # Update globals from defaults even if file not found
        MAX_CONCURRENT_REQUESTS = defaults["max_concurrent_requests"]
        DEFAULT_API_BASE = defaults["api_base_url"]
        DEFAULT_API_MODEL = defaults["api_model_name"]
        return config_to_return

    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            loaded_config_data = json.load(f)

        # Ensure all default keys exist, add missing ones recursively
        def update_recursive(target, source):
            for key, value in source.items():
                if isinstance(value, dict):
                    # Make sure target[key] exists and is a dict before recursing
                    if key not in target or not isinstance(target[key], dict):
                        target[key] = {}
                    target[key] = update_recursive(target[key], value)
                elif key not in target:
                    target[key] = value # Add missing keys
            # Also remove keys from target that are no longer in source (optional, for cleanup)
            # target_keys = list(target.keys())
            # for key in target_keys:
            #     if key not in source:
            #         del target[key]
            return target

        loaded_config_data = update_recursive(loaded_config_data, defaults)

        # --- Load globals and theme ---
        MAX_CONCURRENT_REQUESTS = loaded_config_data.get("max_concurrent_requests", defaults["max_concurrent_requests"])
        DEFAULT_API_BASE = loaded_config_data.get("api_base_url", defaults["api_base_url"])
        DEFAULT_API_MODEL = loaded_config_data.get("api_model_name", defaults["api_model_name"])
        # Ensure theme is loaded into the dict returned for __main__
        # Use the value from loaded_config_data if present, otherwise default
        loaded_config_data["selected_theme"] = loaded_config_data.get("selected_theme", default_theme)


        # Ensure the returned config reflects the loaded/default global values
        loaded_config_data["max_concurrent_requests"] = MAX_CONCURRENT_REQUESTS
        loaded_config_data["api_base_url"] = DEFAULT_API_BASE
        loaded_config_data["api_model_name"] = DEFAULT_API_MODEL

        config_to_return = loaded_config_data # Use the updated loaded data

        print(f"配置加载成功: Max Concurrency={MAX_CONCURRENT_REQUESTS}, API Base={DEFAULT_API_BASE}, Saved Theme='{config_to_return.get('selected_theme', 'N/A')}'")
        return config_to_return

    except (json.JSONDecodeError, IOError) as e:
        print(f"警告: 加载配置文件失败 ({e}), 使用默认设置 (包括主题: {default_theme})。")
        # Ensure globals are set to defaults on failure
        MAX_CONCURRENT_REQUESTS = defaults["max_concurrent_requests"]
        DEFAULT_API_BASE = defaults["api_base_url"]
        DEFAULT_API_MODEL = defaults["api_model_name"]
        # Return the full defaults dictionary, including the default theme
        return defaults

def save_config(config_data):
    """保存配置到文件"""
    global MAX_CONCURRENT_REQUESTS, DEFAULT_API_BASE, DEFAULT_API_MODEL

    try:
        os.makedirs(CONFIG_DIR, exist_ok=True)
        # Update the config data with the current global values before saving
        config_data["max_concurrent_requests"] = MAX_CONCURRENT_REQUESTS
        config_data["api_base_url"] = DEFAULT_API_BASE
        config_data["api_model_name"] = DEFAULT_API_MODEL

        # Remove transient keys if any (optional)
        config_data.pop("batch_size", None)
        config_data.pop("max_concurrent_batches", None)

        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, indent=4, ensure_ascii=False)
    except IOError as e:
        print(f"错误: 保存配置文件失败: {e}")
    except Exception as e:
         print(f"保存配置时发生未知错误: {e}")
         traceback.print_exc()


# --- Helper Functions ---
def format_ass_timestamp(seconds):
    """将秒数格式化为 ASS 时间戳格式 H:MM:SS.cs"""
    delta = datetime.timedelta(seconds=seconds)
    hours, remainder = divmod(delta.total_seconds(), 3600)
    minutes, seconds = divmod(remainder, 60)
    centiseconds = int((seconds - int(seconds)) * 100) # ASS 使用百分秒
    return f"{int(hours)}:{int(minutes):02}:{int(seconds):02}.{centiseconds:02}"

# 确保 re 模块已导入
import re

# --- Helper Functions ---
# ... (format_ass_timestamp 保持不变) ...

# 修改: 使用更精确的键名映射
def generate_style_string(name: str, style_config: dict) -> str:
    """根据配置生成 ASS 样式行，使用精确的键名映射处理大小写。"""
    # 1. 合并配置：以默认值为基础，用特定配置覆盖
    # Start with a deep copy of the defaults to avoid modifying the original
    style_data_lower = {k: v for k, v in DEFAULT_STYLE_DEFAULTS.items()}
    # Update with the specific style configuration provided
    style_data_lower.update({k: v for k, v in style_config.items()})

    # 2. 定义小写键名到 ASS 大小写键名的映射
    key_mapping = {
        "fontname": "Fontname",
        "fontsize": "Fontsize",
        "primary_colour": "PrimaryColour",
        "secondary_colour": "SecondaryColour",
        "outline_colour": "OutlineColour",
        "back_colour": "BackColour",
        "bold": "Bold",
        "italic": "Italic",
        "underline": "Underline",
        "strikeout": "StrikeOut", # Special case S vs s
        "scalex": "ScaleX",       # Special case X vs x
        "scaley": "ScaleY",       # Special case Y vs y
        "spacing": "Spacing",
        "angle": "Angle",
        "borderstyle": "BorderStyle", # Special case S vs s
        "outline": "Outline",
        "shadow": "Shadow",
        "alignment": "Alignment",
        "marginl": "MarginL",     # Special case L vs l
        "marginr": "MarginR",     # Special case R vs r
        "marginv": "MarginV",     # Special case V vs v
        "encoding": "Encoding"
    }

    # 3. 转换键名
    style_data_upper = {}
    for key_lower, value in style_data_lower.items():
        key_upper = key_mapping.get(key_lower) # 从映射中获取正确的键名
        if key_upper:
            style_data_upper[key_upper] = value
        else: # 如果映射中没有，可以选择忽略或警告未知配置项
           print(f"警告: 在样式配置中发现未知键 '{key_lower}'，将被忽略。")

    # 4. 添加样式名称 (ASS 格式需要 'Name')
    style_data_upper["Name"] = name

    # 5. 检查 ASS_STYLE_FORMAT 需要的所有键是否存在
    # Extract keys needed by the format string (e.g., {KeyName})
    required_keys_in_format = set(re.findall(r'\{([^}]+)\}', ASS_STYLE_FORMAT))

    # Find keys that are required by the format but missing in our generated dictionary
    missing_keys = required_keys_in_format - set(style_data_upper.keys())

    if missing_keys:
        print(f"警告: 内部错误，生成样式 '{name}' 时缺少必要的键: {missing_keys}")
        print(f"   当前的字典键: {list(style_data_upper.keys())}")
        # Attempt to fill missing keys with default values as a fallback
        for key in missing_keys:
             fallback_value = "ERROR" # Default fallback value
             # Try to find the corresponding lowercase key and its default value
             for lower_k, upper_k in key_mapping.items():
                 if upper_k == key:
                     # Get value from the original DEFAULT_STYLE_DEFAULTS
                     fallback_value = DEFAULT_STYLE_DEFAULTS.get(lower_k, "MISSING_DEFAULT")
                     break
             style_data_upper[key] = fallback_value
             print(f"   -> 已使用回退值 '{fallback_value}' 填充缺失的键 '{key}'")


    # 6. 使用转换后、键名正确的字典进行格式化
    try:
        # Use the format string with the populated dictionary
        return ASS_STYLE_FORMAT.format(**style_data_upper)
    except KeyError as e:
        print(f"!!! 严重错误: 格式化样式 '{name}' 时仍然发生 KeyError: {e}")
        print(f"   尝试使用的字典键: {list(style_data_upper.keys())}")
        print(f"   ASS 格式需要的键: {required_keys_in_format}")
        # Provide a very basic, safe fallback style line on critical error
        return f"Style: {name},Arial,10,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,10,1 ; Formatting Error Key"
    except Exception as e_fmt:
        print(f"!!! 严重错误: 格式化样式 '{name}' 时发生未知错误: {e_fmt}")
        # Provide a basic fallback style line
        return f"Style: {name},Arial,10,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,10,1 ; Formatting Error Unknown"


# 修改: 使用样式配置
def reconstruct_ass(segments: list[dict], title: str, is_bilingual_mode: bool, style_config: dict) -> str:
    """根据处理后的 segments 生成 ASS 字幕文件内容"""
    # 从配置生成样式行
    # Ensure style_config has the necessary keys, defaulting if not
    default_style_data = style_config.get('style_default', DEFAULT_STYLE_DEFAULTS.copy())
    translated_style_data = style_config.get('style_translated', TRANSLATED_STYLE_DEFAULTS.copy())

    default_style_line = generate_style_string(ASS_DEFAULT_STYLE_NAME, default_style_data)
    translated_style_line = generate_style_string(ASS_TRANSLATED_STYLE_NAME, translated_style_data)

    styles_section = f"{default_style_line}\n{translated_style_line}"
    header = ASS_HEADER_TEMPLATE.format(title=title, styles=styles_section)

    dialogue_lines = []
    for seg in segments:
        start_time_str = format_ass_timestamp(seg['start'])
        end_time_str = format_ass_timestamp(seg['end'])

        # Handle potential None or unexpected types in seg['text']
        seg_text = str(seg.get('text', '')) # Ensure text is a string, default to empty

        # Split bilingual text if applicable
        if is_bilingual_mode and '\n' in seg_text:
            parts = seg_text.split('\n', 1)
            original_text = parts[0].strip().replace('\n', '\\N')
            translated_text = parts[1].strip().replace('\n', '\\N')
            # Apply styles: Translated (top, using TranslatedStyle), Original (bottom, using DefaultStyle)
            ass_text = (
                f"{{\\r{ASS_TRANSLATED_STYLE_NAME}}}{translated_text}" # Translated line with its style
                f"\\N" # New line within the subtitle event
                f"{{\\r{ASS_DEFAULT_STYLE_NAME}}}{original_text}" # Original line with its style
            )
            # The base style for the dialogue line itself (can be overridden by tags)
            style_name_for_line = ASS_DEFAULT_STYLE_NAME
        else:
            # If not bilingual or no newline, treat as single text block using DefaultStyle
            processed_text = seg_text.strip().replace('\n', '\\N')
            ass_text = f"{{\\r{ASS_DEFAULT_STYLE_NAME}}}{processed_text}" # Apply DefaultStyle explicitly
            style_name_for_line = ASS_DEFAULT_STYLE_NAME

        # Construct the ASS Dialogue line
        # Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
        dialogue_line = f"Dialogue: 0,{start_time_str},{end_time_str},{style_name_for_line},,0,0,0,," + ass_text
        dialogue_lines.append(dialogue_line)

    return header + "\n".join(dialogue_lines)


def generate_whisper_segments(result) -> list[dict]:
    """从 Whisper 结果生成初始 segments 列表"""
    segments_data = []; i = 0
    for seg in result.get('segments', []): i += 1; segments_data.append({'index': i, 'start': seg['start'], 'end': seg['end'], 'text': seg['text'].strip()})
    return segments_data

# --- Function to safely parse potentially broken JSON ---
def safe_json_loads(json_string: str) -> dict | None:
    """Attempt to parse JSON, using repair_json if needed."""
    if not openai_available: return None # Can't repair if library not loaded
    try:
        return json.loads(json_string)
    except json.JSONDecodeError:
        try:
            # Ensure repair_json exists before calling
            if 'repair_json' in globals():
                repaired_json_string = repair_json(json_string)
                return json.loads(repaired_json_string)
            else:
                 return None # Cannot repair
        except Exception:
            return None # Repair failed

# --- Async Translation Function (单句处理, 只翻译) ---
# 修改: 增强错误处理和日志
async def translate_single_async(client: AsyncOpenAI, semaphore: asyncio.Semaphore, original_text: str, target_language: str, progress_queue: queue.Queue, model_name: str):
    """异步调用 API 进行单句翻译, 包含更详细的错误处理"""
    prompt = TRANSLATE_ONLY_PROMPT_TEMPLATE.substitute(
        target_language=target_language,
        original_text=original_text
    )
    messages = [{"role": "system", "content": prompt}]
    translated_text = ""
    api_error_occurred = False
    error_message = None
    original_snippet = original_text[:50] # For logging

    async with semaphore:
        try:
            response = await client.chat.completions.create(
                model=model_name, # 使用传入的模型名称
                messages=messages,
                temperature=0.3,
                max_tokens=len(original_text.split()) * 3 + 50, # Estimate max length
                timeout=60.0 # 设置超时 (秒)
            )
            response_content = response.choices[0].message.content.strip()
            # Remove potential leading/trailing quotes added by the model
            if response_content.startswith('"') and response_content.endswith('"'):
                response_content = response_content[1:-1]
            if response_content.startswith("'") and response_content.endswith("'"):
                response_content = response_content[1:-1]

            if response_content:
                translated_text = response_content
            else:
                progress_queue.put(f"警告: API 返回空翻译 for \"{original_snippet}...\".")

        # --- 细化错误捕捉 ---
        except AuthenticationError as auth_err:
            error_message = f"错误: API Key 无效或权限不足 ({auth_err}). 请检查 API Key 和账户状态。"
            api_error_occurred = True
        except RateLimitError as rate_err:
            error_message = f"错误: 达到 API 速率限制 ({rate_err}). 请稍后重试或检查您的 API 配额。"
            api_error_occurred = True
            await asyncio.sleep(5) # Optional: Wait before next attempt if retrying outside
        except APIConnectionError as conn_err:
            error_message = f"错误: 无法连接到 API ({conn_err}). 请检查网络连接和 API Base URL ({client.base_url})."
            api_error_occurred = True
        except APITimeoutError as timeout_err:
             error_message = f"错误: API 请求超时 ({timeout_err}). 网络延迟或服务器繁忙，请稍后重试。"
             api_error_occurred = True
        except InternalServerError as server_err:
             error_message = f"错误: API 服务器内部错误 ({server_err}). 请稍后重试。"
             api_error_occurred = True
        except APIError as api_err: # Catch other generic API errors
            error_message = f"错误: 发生 API 调用错误 ({api_err}). Code: {getattr(api_err, 'code', 'N/A')}, Type: {getattr(api_err, 'type', 'N/A')}"
            api_error_occurred = True
        except Exception as e:
            error_message = f"错误: 调用 API 时发生未知错误 for \"{original_snippet}...\": {e}"
            progress_queue.put(traceback.format_exc()) # Log full traceback for unexpected errors
            api_error_occurred = True
        # --- 错误捕捉结束 ---

        if error_message:
            progress_queue.put(error_message) # Log the specific error

    # Return both the result (or empty string) and error status
    return translated_text, api_error_occurred


# --- Async Wrapper Function for running SINGLE sentence translation ---
# 修改: 接受 api_base 和 model_name
async def run_async_translation(segments_data, target_language, api_key, api_base, model_name, progress_queue):
    """创建异步任务并并发执行单句翻译 API 调用"""
    global MAX_CONCURRENT_REQUESTS # Use the global value set by GUI/config

    if not api_key:
        progress_queue.put("错误: 未提供 API Key，无法进行翻译。")
        return segments_data # Return original segments
    if not api_base:
         progress_queue.put("错误: 未提供 API Base URL，无法进行翻译。")
         return segments_data
    if not model_name:
        progress_queue.put("错误: 未提供 API 模型名称，无法进行翻译。")
        return segments_data

    if not openai_available:
        progress_queue.put("错误: `openai` 库不可用，无法进行翻译。")
        return segments_data

    client = None # Initialize client to None
    try:
        progress_queue.put(f"状态: 连接到 API: {api_base}")
        client = AsyncOpenAI(api_key=api_key, base_url=api_base)
        semaphore = asyncio.Semaphore(MAX_CONCURRENT_REQUESTS) # Use updated global value
        tasks = []
        num_segments = len(segments_data)

        progress_queue.put(f"状态: 创建 {num_segments} 个异步翻译任务 (模型: {model_name}, 最大并发: {MAX_CONCURRENT_REQUESTS})...")

        for i, segment in enumerate(segments_data):
            original_text = segment.get('text', '').strip() # Safely get text
            if not original_text:
                # If original text is empty, just return it without calling API
                tasks.append(asyncio.sleep(0, result=("", False))) # Simulate successful empty task
                continue
            # 修改: 传递 model_name
            task = asyncio.create_task(
                translate_single_async(client, semaphore, original_text, target_language, progress_queue, model_name),
                name=f"translate_task_{i}"
            )
            tasks.append(task)

        start_time = time.time()
        progress_queue.put("状态: 开始并发执行翻译 API 调用...")

        # Use return_exceptions=True to get exceptions instead of raising them
        api_results = await asyncio.gather(*tasks, return_exceptions=True)

        end_time = time.time()
        progress_queue.put(f"状态: 所有翻译 API 调用完成，耗时: {end_time - start_time:.2f} 秒。")

        processed_segments = []
        any_api_error = False # Track if any API error occurred

        for i, segment in enumerate(segments_data):
            result = api_results[i]
            translated_text = ""
            task_failed = False
            original_text = segment.get('text', '') # Get original text again

            if isinstance(result, Exception):
                # Handle exceptions caught by asyncio.gather
                progress_queue.put(f"错误: 翻译任务 {i+1} ('{original_text[:30]}...') 执行时捕获到 gather 异常: {result}")
                task_failed = True
                any_api_error = True # Mark that an error occurred
            elif isinstance(result, tuple) and len(result) == 2:
                # Unpack the result from translate_single_async
                translated_text, api_error_occurred_in_task = result
                if api_error_occurred_in_task:
                    task_failed = True # Mark this specific task had an API error
                    any_api_error = True # Mark that some error occurred in the batch
                # translated_text might be empty if API returned empty or error happened
            else:
                # Handle unexpected result types
                progress_queue.put(f"警告: 翻译任务 {i+1} ('{original_text[:30]}...') 返回非预期结果类型: {type(result)}")
                task_failed = True
                any_api_error = True

            # Combine text based on success and content
            if translated_text and not task_failed:
                # Successfully translated
                bilingual_text = f"{original_text}\n{translated_text}"
            else:
                # If translation failed, API returned empty, or original was empty, keep only original
                bilingual_text = original_text

            # Create the new segment data
            bilingual_segment = segment.copy()
            bilingual_segment['text'] = bilingual_text
            processed_segments.append(bilingual_segment)

        if any_api_error:
            progress_queue.put("警告: 翻译过程中发生一个或多个 API 错误。请检查上面的日志。")

        progress_queue.put("状态: 结果组合完成。")
        return processed_segments

    except Exception as e:
         # Catch errors during client creation or other setup issues
         progress_queue.put(f"错误: 在 run_async_translation 中发生意外错误: {e}")
         progress_queue.put(traceback.format_exc())
         return segments_data # Return original data on major failure
    finally:
        if client:
            await client.close()
            progress_queue.put("状态: API 客户端已关闭。")


# --- Background Processing Thread (处理文件列表) ---
# 添加 stop_event 参数
def process_video_thread(video_paths: list[str], model_name, language, device, progress_queue, refine_enabled, target_language, api_key, api_base, api_model, style_config, stop_event: threading.Event):
    """后台线程，按顺序处理视频文件列表，并在每个文件处理后清理临时文件"""
    total_files = len(video_paths)
    overall_success = True
    user_stopped = False # Flag to track if stopped by user
    whisper_model = None # 初始化模型变量

    # --- 在线程开始时加载 Whisper 模型 ---
    try:
        progress_queue.put(f"\n状态: 正在加载 Whisper 模型 '{model_name}' (设备: {device})...")
        start_load_time = time.time()
        whisper_model = whisper.load_model(model_name, device=device)
        load_time = time.time() - start_load_time
        progress_queue.put(f"状态: Whisper 模型加载完毕 (耗时: {load_time:.2f} 秒)。")
    except Exception as model_load_error:
        progress_queue.put(f"!!! 致命错误: 加载 Whisper 模型 '{model_name}' 失败: {model_load_error}")
        progress_queue.put(traceback.format_exc())
        progress_queue.put("PROCESS_FAILED") # 向 GUI 发送失败信号
        # Clean up model object if partially loaded (though unlikely)
        del whisper_model
        return # 停止线程

    # 检查是否在模型加载后就收到了停止信号
    if stop_event.is_set():
         progress_queue.put("状态: 模型加载后收到停止信号，处理取消。")
         del whisper_model # Clean up loaded model
         progress_queue.put("PROCESS_STOPPED") # Use a specific signal
         return
    # --- 模型加载结束 ---

    for file_index, video_path in enumerate(video_paths):
        # --- 在每个文件处理开始前检查停止信号 ---
        if stop_event.is_set():
            progress_queue.put(f"\n--- 用户请求停止，中止处理文件 {file_index + 1}/{total_files} ---")
            user_stopped = True
            break # 退出循环
        # --- 检查结束 ---

        current_file_num = file_index + 1
        base_name = os.path.splitext(os.path.basename(video_path))[0]
        progress_prefix = f"文件 {current_file_num}/{total_files} ({base_name}): "
        progress_queue.put(f"\n--- {progress_prefix}开始处理 ---")

        temp_audio_path = None # 确保每次循环初始化
        video_clip = None
        audio = None
        output_ass_path = None
        file_success = True

        try:
            output_dir = os.path.dirname(video_path) or '.'
            output_filename = f"{base_name}_bilingual_{target_language}.ass" if refine_enabled else f"{base_name}.ass"
            output_ass_path = os.path.join(output_dir, output_filename)

            # --- 音频提取 ---
            # Check stop event before starting potentially long operation
            if stop_event.is_set(): user_stopped = True; break
            progress_queue.put(f"{progress_prefix}状态: 正在提取音频...")
            video_clip = mp.VideoFileClip(video_path)
            audio = video_clip.audio
            if audio is None: raise ValueError("视频无音轨")
            timestamp_str = str(int(time.time() * 1000))
            temp_audio_filename = f"{base_name}_temp_audio_{timestamp_str}.mp3"
            # Use a more robust temp dir if possible, e.g., tempfile module
            # For simplicity, keeping it in output_dir for now
            temp_audio_path = os.path.join(output_dir, temp_audio_filename)

            os.makedirs(os.path.dirname(temp_audio_path), exist_ok=True)
            # Check stop event again before writing file
            if stop_event.is_set(): user_stopped = True; break
            audio.write_audiofile(temp_audio_path, codec='mp3', logger=None) # Suppress moviepy logger spam
            progress_queue.put(f"{progress_prefix}状态: 音频已提取至 {temp_audio_path}")
            if not os.path.exists(temp_audio_path): raise FileNotFoundError(f"临时音频文件未生成: {temp_audio_path}")
            # --- 音频提取结束 ---

            # --- Whisper 转录 ---
            if stop_event.is_set(): user_stopped = True; break
            progress_queue.put(f"{progress_prefix}状态: 开始转录音频 (使用已加载模型)...")
            # Determine fp16 based on device, not just CUDA availability check done earlier
            use_fp16 = (device == "cuda") # Only use fp16 on CUDA
            transcribe_options = {"fp16": use_fp16}
            if language: transcribe_options["language"] = language

            # Check stop event right before the main transcription call
            if stop_event.is_set(): user_stopped = True; break
            result = whisper_model.transcribe(temp_audio_path, **transcribe_options)
            detected_lang = result.get('language', '未知')
            progress_queue.put(f"{progress_prefix}状态: 转录完成 (检测到语言: {detected_lang})")
            # --- Whisper 转录结束 ---

            segments_data = generate_whisper_segments(result)

            # --- API 翻译 (如果启用) ---
            final_segments = segments_data
            if refine_enabled:
                 if stop_event.is_set(): user_stopped = True; break # Check before async run
                 progress_queue.put(f"{progress_prefix}状态: 开始 API 翻译...")
                 # Make sure API details are valid before calling
                 if not api_key or not api_base or not api_model:
                     progress_queue.put(f"{progress_prefix}错误: API 配置不完整，跳过翻译。")
                 elif not openai_available:
                      progress_queue.put(f"{progress_prefix}错误: OpenAI 库不可用，跳过翻译。")
                 else:
                     progress_queue.put(f"{progress_prefix}状态: 使用 API: {api_base}, 模型: {api_model}")
                     try:
                          # Run the async translation function
                          # Note: The async function itself doesn't check the stop_event;
                          # stopping happens between files or major steps.
                          final_segments = asyncio.run(
                               run_async_translation(segments_data, target_language, api_key, api_base, api_model, progress_queue)
                          )
                     except Exception as async_e:
                          progress_queue.put(f"{progress_prefix}错误: 运行异步翻译时发生异常: {async_e}")
                          progress_queue.put(traceback.format_exc())
                          # Keep original segments if async translation fails globally
                          final_segments = segments_data
                          file_success = False # Mark file as having issues
            else:
                 progress_queue.put(f"{progress_prefix}状态: 未启用 API 翻译。")
            # --- API 翻译结束 ---

             # Check stop event before saving the final file
            if stop_event.is_set(): user_stopped = True; break

            # --- 生成 ASS ---
            progress_queue.put(f"{progress_prefix}状态: 正在生成 ASS 字幕内容...")
            final_ass_content = reconstruct_ass(final_segments, base_name, refine_enabled, style_config)
            progress_queue.put(f"{progress_prefix}状态: 正在保存最终 ASS 文件到:\n{output_ass_path}")
            with open(output_ass_path, 'w', encoding='utf-8') as ass_file:
                ass_file.write(final_ass_content)
            progress_queue.put(f"{progress_prefix}成功: 字幕文件已保存。")
            # --- 生成 ASS 结束 ---

        except Exception as e:
            file_success = False
            overall_success = False # Any file failure marks overall as not fully successful
            error_msg = f"{progress_prefix}错误: 处理过程中发生异常:\n{e}"
            progress_queue.put(traceback.format_exc())
            progress_queue.put(error_msg)
        finally:
            # --- 文件级清理 ---
            # Close handles first to release files
            if audio:
                try: audio.close()
                except Exception as e_clean: progress_queue.put(f"{progress_prefix}警告: 关闭音频对象时出错: {e_clean}")
            if video_clip:
                try: video_clip.close()
                except Exception as e_clean: progress_queue.put(f"{progress_prefix}警告: 关闭视频对象时出错: {e_clean}")

            # -------- 删除临时音频文件 --------
            if temp_audio_path and os.path.exists(temp_audio_path):
                try:
                    os.remove(temp_audio_path)
                    progress_queue.put(f"{progress_prefix}状态: 已删除临时音频文件: {temp_audio_path}")
                except PermissionError as e_perm:
                    progress_queue.put(f"{progress_prefix}警告: 删除临时文件失败 (权限错误): {temp_audio_path} ({e_perm})")
                    overall_success = False # Mark batch as potentially problematic
                except OSError as e_os:
                     progress_queue.put(f"{progress_prefix}警告: 删除临时文件失败 (OS错误，可能被占用?): {temp_audio_path} ({e_os})")
                     overall_success = False
                except Exception as e_clean:
                    progress_queue.put(f"{progress_prefix}警告: 删除临时音频文件时发生未知错误: {temp_audio_path} ({e_clean})")
                    overall_success = False
            elif temp_audio_path:
                # If path exists but file doesn't (e.g., failed write_audiofile)
                 progress_queue.put(f"{progress_prefix}状态: 临时音频文件未找到或无需删除: {temp_audio_path}")
            # -------- 删除逻辑结束 --------

            # --- 发送文件完成信号给进度条 ---
            # Only update progress if not stopped and file processed (even if failed)
            if not user_stopped:
                progress_queue.put(("FILE_COMPLETE", current_file_num, total_files))
            # --- 进度条更新结束 ---

            # --- Check stop event again at the end of the loop ---
            if stop_event.is_set():
                user_stopped = True
                # No need to break here, loop condition will handle it


    # --- 线程结束 ---
    # Clean up the Whisper model from memory
    if whisper_model:
        progress_queue.put("状态: 正在卸载 Whisper 模型...")
        try:
             # Whisper doesn't have an explicit unload, relying on GC
             del whisper_model
             if torch.cuda.is_available(): torch.cuda.empty_cache() # Clear VRAM if CUDA was used
             progress_queue.put("状态: Whisper 模型已卸载 (或等待 GC)。")
        except Exception as e_unload:
            progress_queue.put(f"警告: 卸载 Whisper 模型时出错: {e_unload}")


    # 发送最终状态信号
    if user_stopped:
        progress_queue.put("\n--- 处理已被用户停止 ---")
        progress_queue.put("PROCESS_STOPPED") # 发送停止信号
    elif overall_success:
        progress_queue.put("\n--- 所有文件处理完毕 ---")
        progress_queue.put("PROCESS_COMPLETE")
    else:
        # Some files failed, or cleanup failed
        progress_queue.put("\n--- 部分或全部文件处理完成，但可能存在错误 ---")
        progress_queue.put("PROCESS_FAILED") # Use FAILED signal


# --- GUI Class ---
class SubtitleApp:
    def __init__(self, root):
        self.root = root
        self.root.title("字幕生成器 (Whisper + API 翻译 - Batch ASS)")
        self.root.geometry("950x900") # Increased size slightly for new buttons

        # Load config first to potentially get theme setting for GUI elements
        self.config = load_config()

        # --- GUI 变量 ---
        self.file_list = []
        self.path_input_var = tk.StringVar()
        self.selected_model_var = tk.StringVar(value=self.config.get("whisper_model", "base"))
        self.language_var = tk.StringVar(value=self.config.get("whisper_language", "en"))
        self.device_var = tk.StringVar(value=self.config.get("device", "自动检测"))
        self.refine_var = tk.BooleanVar(value=self.config.get("enable_refinement", False))
        self.api_key_var = tk.StringVar(value=self.config.get("api_key", ""))
        self.api_base_url_var = tk.StringVar(value=self.config.get("api_base_url", DEFAULT_API_BASE))
        self.api_model_name_var = tk.StringVar(value=self.config.get("api_model_name", DEFAULT_API_MODEL))
        self.target_lang_var = tk.StringVar(value=self.config.get("target_language", "中文"))
        self.max_concurrent_var = tk.IntVar(value=self.config.get("max_concurrent_requests", DEFAULT_MAX_CONCURRENT_REQUESTS))
        self.style_default_fontsize_var = tk.IntVar(value=self.config.get("style_default", {}).get("fontsize", DEFAULT_STYLE_DEFAULTS["fontsize"]))
        self.style_default_color_var = tk.StringVar(value=self.config.get("style_default", {}).get("primary_colour", DEFAULT_STYLE_DEFAULTS["primary_colour"]))
        self.style_translated_fontsize_var = tk.IntVar(value=self.config.get("style_translated", {}).get("fontsize", TRANSLATED_STYLE_DEFAULTS["fontsize"]))
        self.style_translated_color_var = tk.StringVar(value=self.config.get("style_translated", {}).get("primary_colour", TRANSLATED_STYLE_DEFAULTS["primary_colour"]))
        initial_gui_theme = self.config.get("selected_theme", "clam")
        self.selected_theme_var = tk.StringVar(value=initial_gui_theme)
        # --- GUI 变量结束 ---

        self.progress_queue = queue.Queue()
        self.processing_thread = None
        self.stop_event = threading.Event()
        self.whisper_model = None
        self.available_themes = [] # Initialize available themes list

        # --- 创建控件 ---
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- 顶部区域: 文件选择 ---
        file_area_frame = ttk.LabelFrame(main_frame, text="输入/选择文件", padding="5")
        file_area_frame.pack(fill=tk.X, pady=5)
        path_frame = ttk.Frame(file_area_frame)
        path_frame.pack(fill=tk.X, pady=(0,5))
        ttk.Label(path_frame, text="路径跳转:").pack(side=tk.LEFT, padx=(0,5))
        self.path_entry = ttk.Entry(path_frame, textvariable=self.path_input_var)
        self.path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0,5))
        self.go_to_path_button = ttk.Button(path_frame, text="打开此路径添加", command=self.go_to_path_and_add)
        self.go_to_path_button.pack(side=tk.LEFT)
        file_list_outer_frame = ttk.Frame(file_area_frame)
        file_list_outer_frame.pack(fill=tk.X, expand=True)
        listbox_frame = ttk.Frame(file_list_outer_frame)
        listbox_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        self.file_listbox = tk.Listbox(listbox_frame, selectmode=tk.EXTENDED, width=70, height=6)
        self.file_listbox_scrollbar_y = ttk.Scrollbar(listbox_frame, orient=tk.VERTICAL, command=self.file_listbox.yview)
        self.file_listbox_scrollbar_x = ttk.Scrollbar(listbox_frame, orient=tk.HORIZONTAL, command=self.file_listbox.xview)
        self.file_listbox.config(yscrollcommand=self.file_listbox_scrollbar_y.set, xscrollcommand=self.file_listbox_scrollbar_x.set)
        self.file_listbox_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        self.file_listbox_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        self.file_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        file_button_frame = ttk.Frame(file_list_outer_frame)
        file_button_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5)
        self.add_files_button = ttk.Button(file_button_frame, text="添加文件...", command=self.add_files)
        self.add_files_button.pack(pady=2, fill=tk.X)
        self.remove_files_button = ttk.Button(file_button_frame, text="移除选中", command=self.remove_selected_files)
        self.remove_files_button.pack(pady=2, fill=tk.X)
        self.select_all_button = ttk.Button(file_button_frame, text="全选", command=self.select_all_files)
        self.select_all_button.pack(pady=2, fill=tk.X)
        self.clear_all_button = ttk.Button(file_button_frame, text="清空列表", command=self.clear_all_files)
        self.clear_all_button.pack(pady=2, fill=tk.X)

        # --- 设置区域 Notebook ---
        settings_notebook = ttk.Notebook(main_frame)
        self.settings_notebook = settings_notebook
        settings_notebook.pack(fill=tk.X, pady=10)

        # --- Tab 1: Core Settings ---
        tab_core = ttk.Frame(settings_notebook, padding=10)
        settings_notebook.add(tab_core, text="核心设置")
        tab_core.columnconfigure(0, weight=1)
        tab_core.columnconfigure(1, weight=1)
        tab_core.columnconfigure(2, weight=1)
        whisper_frame = ttk.LabelFrame(tab_core, text="Whisper", padding=5)
        whisper_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        ttk.Label(whisper_frame, text="模型:").pack(anchor='w')
        model_options = ["tiny", "base", "small", "medium", "large", "large-v2", "large-v3"] + [m + ".en" for m in ["tiny", "base", "small", "medium"]]
        self.model_combo = ttk.Combobox(whisper_frame, textvariable=self.selected_model_var, values=model_options, state='readonly', width=12)
        self.model_combo.pack(anchor='w', pady=(0, 5), fill=tk.X)
        ttk.Label(whisper_frame, text="设备:").pack(anchor='w')
        device_options = ["自动检测", "cuda", "cpu"]
        self.device_combo = ttk.Combobox(whisper_frame, textvariable=self.device_var, values=device_options, state='readonly', width=10)
        self.device_combo.pack(anchor='w', pady=(0, 5), fill=tk.X)
        ttk.Label(whisper_frame, text="源语言:").pack(anchor='w')
        self.lang_entry = ttk.Entry(whisper_frame, textvariable=self.language_var, width=7)
        self.lang_entry.pack(anchor='w', side=tk.LEFT, padx=(0,5))
        ttk.Label(whisper_frame, text="(留空自动)").pack(anchor='w', side=tk.LEFT)
        api_enable_frame = ttk.LabelFrame(tab_core, text="API / 双语", padding=5)
        api_enable_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        self.refine_check = ttk.Checkbutton(api_enable_frame, text="启用 API 翻译/双语字幕", variable=self.refine_var, onvalue=True, offvalue=False, state=tk.NORMAL if openai_available else tk.DISABLED, command=self.toggle_api_options)
        self.refine_check.pack(anchor='w', pady=(0, 10))
        self.target_lang_label = ttk.Label(api_enable_frame, text="目标语言:")
        common_languages = ["中文", "English", "日本語", "한국어", "Français", "Deutsch", "Español", "Русский", "繁體中文"]
        saved_lang = self.config.get("target_language", "中文")
        if saved_lang not in common_languages: common_languages.insert(0, saved_lang)
        self.target_lang_combo = ttk.Combobox(api_enable_frame, textvariable=self.target_lang_var, values=common_languages, width=15)
        api_concurrency_frame = ttk.LabelFrame(tab_core, text="API 并发", padding=5)
        api_concurrency_frame.grid(row=0, column=2, padx=5, pady=5, sticky="nsew")
        self.concurrency_label = ttk.Label(api_concurrency_frame, text="最大并发请求数:")
        self.concurrency_spinbox = ttk.Spinbox(api_concurrency_frame, from_=1, to=100, textvariable=self.max_concurrent_var, width=5, command=self.update_concurrency_setting)

        # --- Tab 2: API Endpoint ---
        tab_api = ttk.Frame(settings_notebook, padding=10)
        settings_notebook.add(tab_api, text="API 端点")
        ttk.Label(tab_api, text="API Key:").pack(anchor='w')
        self.api_key_entry = ttk.Entry(tab_api, textvariable=self.api_key_var, width=60, show="*")
        self.api_key_entry.pack(anchor='w', fill=tk.X, pady=(0, 10))
        ttk.Label(tab_api, text="API Base URL (兼容 OpenAI 格式):").pack(anchor='w')
        self.api_base_url_entry = ttk.Entry(tab_api, textvariable=self.api_base_url_var, width=60)
        self.api_base_url_entry.pack(anchor='w', fill=tk.X, pady=(0, 5))
        ttk.Button(tab_api, text="重置为 DeepSeek", command=lambda: self.api_base_url_var.set(DEFAULT_API_BASE)).pack(anchor='w',pady=(0,10))
        ttk.Label(tab_api, text="API 模型名称:").pack(anchor='w')
        self.api_model_name_entry = ttk.Entry(tab_api, textvariable=self.api_model_name_var, width=60)
        self.api_model_name_entry.pack(anchor='w', fill=tk.X, pady=(0, 5))
        ttk.Button(tab_api, text="重置为 DeepSeek Chat", command=lambda: self.api_model_name_var.set(DEFAULT_API_MODEL)).pack(anchor='w',pady=(0,10))

        # --- Tab 3: Subtitle Style ---
        tab_style = ttk.Frame(settings_notebook, padding=10)
        settings_notebook.add(tab_style, text="字幕样式 (ASS)")
        style_frame_default = ttk.LabelFrame(tab_style, text="默认样式 (原文)", padding=5)
        style_frame_default.pack(side=tk.LEFT, padx=10, anchor='n', fill=tk.Y)
        style_frame_translated = ttk.LabelFrame(tab_style, text="翻译样式", padding=5)
        style_frame_translated.pack(side=tk.LEFT, padx=10, anchor='n', fill=tk.Y)
        ttk.Label(style_frame_default, text="字号:").pack(anchor='w')
        self.style_default_fs_spinbox = ttk.Spinbox(style_frame_default, from_=8, to=72, textvariable=self.style_default_fontsize_var, width=5)
        self.style_default_fs_spinbox.pack(anchor='w', pady=(0, 5))
        ttk.Label(style_frame_default, text="主颜色 (&HAABBGGR&):").pack(anchor='w')
        self.style_default_color_entry = ttk.Entry(style_frame_default, textvariable=self.style_default_color_var, width=15)
        self.style_default_color_entry.pack(anchor='w', pady=(0, 5))
        self.style_default_color_button = ttk.Button(style_frame_default, text="选择颜色...", command=lambda: self.select_color(self.style_default_color_var))
        self.style_default_color_button.pack(anchor='w')
        ttk.Label(style_frame_translated, text="字号:").pack(anchor='w')
        self.style_translated_fs_spinbox = ttk.Spinbox(style_frame_translated, from_=8, to=72, textvariable=self.style_translated_fontsize_var, width=5)
        self.style_translated_fs_spinbox.pack(anchor='w', pady=(0, 5))
        ttk.Label(style_frame_translated, text="主颜色 (&HAABBGGR&):").pack(anchor='w')
        self.style_translated_color_entry = ttk.Entry(style_frame_translated, textvariable=self.style_translated_color_var, width=15)
        self.style_translated_color_entry.pack(anchor='w', pady=(0, 5))
        self.style_translated_color_button = ttk.Button(style_frame_translated, text="选择颜色...", command=lambda: self.select_color(self.style_translated_color_var))
        self.style_translated_color_button.pack(anchor='w')

        # --- 控制按钮 Frame ---
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=10)
        self.start_button = ttk.Button(control_frame, text="开始处理选中文件", command=self.start_processing, state=tk.DISABLED)
        self.start_button.pack(side=tk.LEFT, padx=(10, 5))
        self.stop_button = ttk.Button(control_frame, text="停止处理", command=self.request_stop, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        self.progressbar = ttk.Progressbar(control_frame, orient=tk.HORIZONTAL, length=300, mode='determinate')
        self.progressbar.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        self.restart_button = ttk.Button(control_frame, text="重启应用", command=self.restart_application)
        self.restart_button.pack(side=tk.LEFT, padx=(5, 10))

        # --- 日志区域 Frame (创建 self.log_area) ---
        log_frame = ttk.LabelFrame(main_frame, text="处理日志", padding="5")
        log_frame.pack(fill=tk.BOTH, expand=True, pady=(5,0))
        self.log_area = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=12, state=tk.DISABLED)
        self.log_area.pack(fill=tk.BOTH, expand=True)

        # --- Tab 4: Appearance (Theme) - 创建并初始化 ---
        tab_appearance = ttk.Frame(settings_notebook, padding=10)
        if use_themes and isinstance(self.root, ThemedTk):
            settings_notebook.add(tab_appearance, text="外观") # Add tab to notebook
            theme_frame = ttk.LabelFrame(tab_appearance, text="界面主题", padding=5)
            theme_frame.pack(pady=5, padx=5, fill=tk.X)
            ttk.Label(theme_frame, text="选择主题:").pack(side=tk.LEFT, padx=(0, 5))
            # 创建 Combobox
            self.theme_combobox = ttk.Combobox(theme_frame, textvariable=self.selected_theme_var, state='readonly', width=20)
            self.theme_combobox.pack(side=tk.LEFT, padx=5)
            # 尝试填充并绑定事件
            try:
                self.available_themes = sorted(self.root.get_themes()) # Get themes
                self.theme_combobox['values'] = self.available_themes
                current_theme_in_var = self.selected_theme_var.get()
                # 验证或重置 Combobox 的初始值
                if current_theme_in_var not in self.available_themes:
                    print(f"警告: 变量中的主题 '{current_theme_in_var}' 不可用，将尝试重置。")
                    try:
                         actual_theme = self.root.current_theme
                         if actual_theme in self.available_themes:
                              self.selected_theme_var.set(actual_theme)
                              print(f"     已重置为当前活动主题: {actual_theme}")
                         elif self.available_themes:
                              self.selected_theme_var.set(self.available_themes[0])
                              print(f"     已重置为第一个可用主题: {self.available_themes[0]}")
                         else:
                              self.theme_combobox.config(state=tk.DISABLED)
                    except AttributeError: # Fallback if current_theme not available
                         if self.available_themes:
                             self.selected_theme_var.set(self.available_themes[0])
                             print(f"     已重置为第一个可用主题 (回退): {self.available_themes[0]}")
                         else:
                              self.theme_combobox.config(state=tk.DISABLED)
                # 绑定事件处理函数（确保 apply_selected_theme 方法已定义）
                if self.theme_combobox['state'] != tk.DISABLED:
                     self.theme_combobox.bind("<<ComboboxSelected>>", self.apply_selected_theme)
            except Exception as e:
                print(f"错误: 获取或设置主题列表时出错: {e}")
                if hasattr(self, 'theme_combobox'):
                    self.theme_combobox.config(state=tk.DISABLED)
                self.log_append("错误：无法加载主题列表。")
        else:
            # 如果未使用主题，不添加外观选项卡
            print("信息：未使用 ttkthemes，外观选项卡已禁用。")
        # --- Appearance Tab End ---

        # --- 初始设置调用 ---
        # Call this *after* all related widgets are created
        self.toggle_api_options()
        # 尝试初始化拖放功能
        self._initialize_drag_drop()

        # --- 初始日志消息 ---
        self.log_append("应用程序启动。")
        if not openai_available: self.log_append("警告: `openai` 库未找到或版本过低, API 功能已禁用。")
        if not self.api_key_var.get() and self.config.get("enable_refinement", False):
            self.log_append("提示: 检测到上次启用了 API 功能，但当前未配置 API Key。")
        if not self.available_themes and use_themes:
             self.log_append("警告：未能加载主题列表，主题切换功能可能受限。")

        # --- 最后设置 ---
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.update_control_states() # Ensure initial button states are correct
        self.check_queue() # 启动队列检查循环

    # --- 方法定义 ---

    def _initialize_drag_drop(self):
        """Attempts to initialize drag & drop for the file listbox."""
        try:
            from tkinterdnd2 import DND_FILES, TkinterDnD
            if hasattr(self, 'file_listbox') and self.file_listbox and self.file_listbox.winfo_exists():
                self.file_listbox.drop_target_register(DND_FILES)
                self.file_listbox.dnd_bind('<<Drop>>', self.handle_drop)
                print("拖放功能已尝试启用 (需要 tkinterdnd2-universal)。")
                self.log_append("提示: 文件列表支持拖放添加文件。")
            else:
                print("警告: 文件列表框未准备好，无法初始化拖放。")
                self.log_append("警告: 拖放初始化失败（列表框未就绪）。")
        except ImportError:
            print("提示: 未安装 `tkinterdnd2-universal` 库，无法启用拖放文件功能。")
        except tk.TclError as e:
            print(f"错误: 初始化拖放功能失败 (TclError): {e}")
            print("     拖放功能将不可用。")
            self.log_append("警告: 初始化拖放功能失败，该功能可能不可用。")
        except Exception as e_dnd:
            print(f"错误: 初始化拖放功能时发生未知错误: {e_dnd}")
            self.log_append("警告: 初始化拖放时出错，该功能可能不可用。")

    def handle_drop(self, event):
        """Handles file drops onto the listbox."""
        print(f"拖放事件数据: {event.data}")
        try:
            import re
            filepaths = re.findall(r'\{.*?\}|\S+', event.data)
            filepaths = [fp.strip().strip('{}').strip() for fp in filepaths if fp.strip()]
            if filepaths:
                print(f"解析到的文件路径: {filepaths}")
                self.add_file_paths(filepaths)
            else:
                self.log_append("警告：无法从拖放事件解析文件路径。")
        except ImportError:
             self.log_append("错误: 处理拖放需要 `tkinterdnd2` 库，请安装。")
        except Exception as e:
            self.log_append(f"处理拖放事件时出错: {e}")
            traceback.print_exc()

    def apply_selected_theme(self, event=None):
        """Applies the theme selected in the Combobox."""
        new_theme = self.selected_theme_var.get()
        if not use_themes or not isinstance(self.root, ThemedTk):
            print("错误: 无法应用主题，因为未使用 ThemedTk。")
            return

        try:
            print(f"正在尝试应用主题: {new_theme}")
            self.root.set_theme(new_theme)
            self.log_append(f"界面主题已切换为: {new_theme}")
            self.config["selected_theme"] = new_theme # Update config dict immediately
            # Note: config file isn't saved until exit/restart unless you call save_config here
            print(f"主题 '{new_theme}' 应用成功。")
        except tk.TclError as e:
            print(f"错误: 应用主题 '{new_theme}' 失败 (TclError): {e}")
            self.log_append(f"错误: 无法应用主题 '{new_theme}'。")
            messagebox.showerror("主题错误", f"无法应用主题 '{new_theme}'。\n错误: {e}")
            try: # Try to revert combobox to the theme that is actually active
                 current_actual_theme = self.root.current_theme
                 if current_actual_theme in self.available_themes:
                     self.selected_theme_var.set(current_actual_theme)
            except Exception: pass # Ignore errors during revert
        except Exception as e:
            print(f"错误: 应用主题 '{new_theme}' 时发生未知错误: {e}")
            self.log_append(f"错误: 应用主题时发生未知错误。")
            messagebox.showerror("主题错误", f"应用主题 '{new_theme}' 时发生未知错误。")

    def select_color(self, color_var):
        """Opens color chooser and updates the variable with ASS format."""
        current_ass_color = color_var.get()
        initial_color = "#FFFFFF"
        match = re.match(r"&H([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})&?$", current_ass_color, re.IGNORECASE)
        if match:
            aa, bb, gg, rr = match.groups()
            if all(len(c) == 2 for c in [rr, gg, bb]):
                initial_color = f"#{rr}{gg}{bb}".upper()
            else:
                print(f"警告: 从 '{current_ass_color}' 提取的 R/G/B 分量无效，使用默认颜色 #FFFFFF。")
        elif current_ass_color:
            print(f"警告: 当前颜色值 '{current_ass_color}' 不是有效的 ASS 格式 (&HAABBGGR&)，颜色选择器将使用默认初始颜色 #FFFFFF。")

        try:
            color_code = colorchooser.askcolor(title="选择颜色", initialcolor=initial_color)
            if color_code and color_code[1]:
                hex_color = color_code[1].lstrip('#')
                r_hex, g_hex, b_hex = hex_color[0:2], hex_color[2:4], hex_color[4:6]
                ass_color = f"&H00{b_hex}{g_hex}{r_hex}&".upper()
                color_var.set(ass_color)
        except tk.TclError as e:
            messagebox.showerror("颜色选择器错误", f"无法打开颜色选择器或设置颜色。\n错误: {e}\n请检查初始颜色值: '{initial_color}'")
            print(f"颜色选择器 TclError: {e} (尝试使用 initialcolor='{initial_color}')")
        except Exception as e_chooser:
             messagebox.showerror("颜色选择器错误", f"打开颜色选择器时发生未知错误: {e_chooser}")
             print(f"颜色选择器未知错误: {e_chooser}")

    # --- 新增: 只保存设置的方法 ---
    def _save_settings_on_exit(self):
        """Saves current settings to the config file without closing."""
        print("正在保存设置...")
        global MAX_CONCURRENT_REQUESTS, DEFAULT_API_BASE, DEFAULT_API_MODEL
        try: MAX_CONCURRENT_REQUESTS = self.max_concurrent_var.get()
        except (tk.TclError, ValueError): pass
        try: DEFAULT_API_BASE = self.api_base_url_var.get()
        except tk.TclError: pass
        try: DEFAULT_API_MODEL = self.api_model_name_var.get()
        except tk.TclError: pass

        current_config = {
            "api_key": self.api_key_var.get(),
            "api_base_url": self.api_base_url_var.get(),
            "api_model_name": self.api_model_name_var.get(),
            "whisper_model": self.selected_model_var.get(),
            "whisper_language": self.language_var.get(),
            "device": self.device_var.get(),
            "enable_refinement": self.refine_var.get(),
            "target_language": self.target_lang_var.get(),
            "max_concurrent_requests": self.max_concurrent_var.get(),
            "style_default": {**self.config.get("style_default", DEFAULT_STYLE_DEFAULTS),
                              "fontsize": self.style_default_fontsize_var.get(),
                              "primary_colour": self.style_default_color_var.get()},
            "style_translated": {**self.config.get("style_translated", TRANSLATED_STYLE_DEFAULTS),
                                 "fontsize": self.style_translated_fontsize_var.get(),
                                 "primary_colour": self.style_translated_color_var.get()},
            # Save theme, ensuring variable exists and we check use_themes
            "selected_theme": self.selected_theme_var.get() if use_themes and hasattr(self, 'selected_theme_var') else self.config.get("selected_theme", "clam")
        }
        # Update self.config before saving (or save current_config directly)
        self.config = current_config
        save_config(self.config)
        print("设置已保存。")

    def on_closing(self):
        """Handles the window close event (WM_DELETE_WINDOW)."""
        print("关闭窗口请求...")
        close_window = True
        if self.processing_thread and self.processing_thread.is_alive():
            if messagebox.askyesno("确认退出", "处理仍在进行中。确定要强制退出吗？\n（这可能导致当前文件处理不完整）"):
                print("用户选择在处理期间强制退出。正在尝试停止线程...")
                self.request_stop()
            else:
                print("退出取消，处理将继续。")
                close_window = False

        if close_window:
            self._save_settings_on_exit() # Save settings first
            print("正在关闭窗口...")
            self.root.destroy() # Then destroy
        else:
             print("窗口未关闭。")

    def restart_application(self):
        """Restarts the current application."""
        confirm_msg = "确定要重启应用程序吗？"
        can_restart = True

        if self.processing_thread and self.processing_thread.is_alive():
             confirm_msg += "\n\n警告：处理仍在进行中！重启将尝试停止当前任务并可能导致数据丢失或处理不完整。"
             if not messagebox.askyesno("重启确认", confirm_msg):
                  print("重启取消。")
                  can_restart = False
             else:
                  print("用户确认重启，正在尝试停止当前处理...")
                  self.request_stop()
                  self.root.update_idletasks()
                  time.sleep(0.1)
        elif not messagebox.askyesno("重启确认", confirm_msg):
             print("重启取消。")
             can_restart = False

        if not can_restart:
            return

        print("正在准备重启...")
        self._save_settings_on_exit() # Save settings BEFORE attempting restart

        try:
            print("尝试执行重启...")
            python_executable = sys.executable
            script_path = os.path.abspath(sys.argv[0])
            args = [python_executable, script_path] + sys.argv[1:]
            print(f"  执行: {' '.join(args)}")
            os.execv(python_executable, args) # Replaces current process

        except Exception as e:
             # This block only runs if os.execv FAILED
             error_msg = f"重启失败: {e}\n请手动关闭并重新启动应用程序。"
             print(f"错误: {error_msg}")
             messagebox.showerror("重启错误", error_msg)
             traceback.print_exc()
             print("重启失败，正在关闭旧窗口...")
             try: # Try to close the old window after showing the error
                 if self.root and self.root.winfo_exists():
                    self.root.destroy()
             except Exception as destroy_err:
                 print(f"关闭旧窗口时发生错误: {destroy_err}")


    def toggle_api_options(self):
        """Enables/disables API related options based on the checkbox."""
        is_enabled = self.refine_var.get() and openai_available
        widget_state = tk.NORMAL if is_enabled else tk.DISABLED
        combo_state = 'normal' if is_enabled else tk.DISABLED # Combobox text entry needs 'normal'

        # Pack/Unpack API related widgets in the core tab
        if is_enabled:
            # Check if widget exists before packing (safer)
            if hasattr(self, 'target_lang_label'): self.target_lang_label.pack(anchor='w', pady=(0, 5), in_=self.target_lang_label.master)
            if hasattr(self, 'target_lang_combo'): self.target_lang_combo.pack(anchor='w', pady=(0, 10), after=self.target_lang_label, in_=self.target_lang_combo.master, fill=tk.X)
            if hasattr(self, 'concurrency_label'): self.concurrency_label.pack(anchor='w', pady=(0, 5), in_=self.concurrency_label.master)
            if hasattr(self, 'concurrency_spinbox'): self.concurrency_spinbox.pack(anchor='w', after=self.concurrency_label, in_=self.concurrency_spinbox.master)
        else:
            if hasattr(self, 'target_lang_label'): self.target_lang_label.pack_forget()
            if hasattr(self, 'target_lang_combo'): self.target_lang_combo.pack_forget()
            if hasattr(self, 'concurrency_label'): self.concurrency_label.pack_forget()
            if hasattr(self, 'concurrency_spinbox'): self.concurrency_spinbox.pack_forget()

        # Enable/disable API tab widgets
        if hasattr(self, 'api_key_entry'): self.api_key_entry.config(state=widget_state)
        if hasattr(self, 'api_base_url_entry'): self.api_base_url_entry.config(state=widget_state)
        if hasattr(self, 'api_model_name_entry'): self.api_model_name_entry.config(state=widget_state)

        # Enable/disable translated style widgets
        if hasattr(self, 'style_translated_fs_spinbox'): self.style_translated_fs_spinbox.config(state=widget_state)
        if hasattr(self, 'style_translated_color_entry'): self.style_translated_color_entry.config(state=widget_state)
        if hasattr(self, 'style_translated_color_button'): self.style_translated_color_button.config(state=widget_state)


    def update_concurrency_setting(self):
        """Callback when spinbox value changes, updates global variable."""
        global MAX_CONCURRENT_REQUESTS
        try:
            new_value = self.max_concurrent_var.get()
            if new_value >= 1:
                if MAX_CONCURRENT_REQUESTS != new_value:
                    MAX_CONCURRENT_REQUESTS = new_value
                    print(f"API 并发数已更新为: {MAX_CONCURRENT_REQUESTS}")
            else:
                self.max_concurrent_var.set(MAX_CONCURRENT_REQUESTS)
        except (tk.TclError, ValueError):
            print("警告: 并发数输入无效。")
            self.max_concurrent_var.set(MAX_CONCURRENT_REQUESTS)

    def add_files(self, initial_dir=None):
        """Opens file dialog to add files."""
        start_dir = self.path_input_var.get().strip()
        if not os.path.isdir(start_dir):
            start_dir = initial_dir or os.path.expanduser("~")
        filepaths = filedialog.askopenfilenames(
            title="选择视频/音频文件", initialdir=start_dir,
            filetypes=(("媒体文件", "*.mp4 *.avi *.mov *.mkv *.flv *.wmv *.mp3 *.wav *.m4a *.ogg"),("所有文件", "*.*"))
        )
        if filepaths:
            self.add_file_paths(filepaths)

    def add_file_paths(self, filepaths):
        """Helper function to add a list of file paths to the listbox."""
        added_count = 0
        current_files_in_list = set(self.file_list)
        for fp in filepaths:
            try:
                fp_norm = os.path.normpath(fp)
                if os.path.isfile(fp_norm) and fp_norm not in current_files_in_list:
                    self.file_list.append(fp_norm)
                    self.file_listbox.insert(tk.END, os.path.basename(fp_norm))
                    current_files_in_list.add(fp_norm)
                    added_count += 1
                elif fp_norm in current_files_in_list:
                     print(f"文件已存在于列表中: {os.path.basename(fp_norm)}")
                elif not os.path.isfile(fp_norm):
                    print(f"跳过无效文件或目录: {fp_norm}")
            except Exception as e:
                print(f"添加文件时出错 '{fp}': {e}")
        if added_count > 0:
             self.log_append(f"已添加 {added_count} 个新文件。")
             self.update_control_states()
        else:
            self.log_append("未添加新文件。")

    def remove_selected_files(self):
        """Removes selected files from the listbox and internal list."""
        selected_indices = self.file_listbox.curselection()
        if not selected_indices:
             messagebox.showwarning("提示", "请先在列表中选择要移除的文件。")
             return
        removed_count = 0
        for index in reversed(selected_indices):
            try:
                self.file_list.pop(index)
                self.file_listbox.delete(index)
                removed_count += 1
            except IndexError:
                print(f"移除文件时索引错误: {index}")
        if removed_count > 0:
             self.log_append(f"共移除 {removed_count} 个文件。")
             self.update_control_states()
        if not self.file_list:
            self.log_append("文件列表已清空。")

    def select_all_files(self):
        """Selects all items in the file listbox."""
        if self.file_listbox.size() > 0:
             self.file_listbox.select_set(0, tk.END)

    def clear_all_files(self):
        """Removes all items from the file list."""
        if not self.file_list:
            self.log_append("列表已为空，无需清空。")
            return
        if messagebox.askyesno("确认", "确定要清空文件列表吗？"):
            self.file_list.clear()
            self.file_listbox.delete(0, tk.END)
            self.log_append("文件列表已清空。")
            self.update_control_states()

    def go_to_path_and_add(self):
        """Opens file dialog starting from the path entry."""
        path_to_open = self.path_input_var.get().strip()
        if not path_to_open:
             path_to_open = os.path.expanduser("~")
             self.path_input_var.set(path_to_open)

        effective_path = path_to_open
        if not os.path.isdir(path_to_open):
             parent_dir = os.path.dirname(path_to_open)
             if os.path.isdir(parent_dir):
                 effective_path = parent_dir
             else:
                 messagebox.showerror("错误", f"无法找到有效的目录:\n'{path_to_open}'\n或其父目录。")
                 return
        self.add_files(initial_dir=effective_path)

    def request_stop(self):
        """Sets the stop event to signal the background thread."""
        if self.processing_thread and self.processing_thread.is_alive():
            self.log_append("\n*** 用户请求停止处理... (请等待当前文件处理完毕或主要步骤完成) ***")
            self.stop_event.set()
            self.update_control_states() # Update button states immediately

    def start_processing(self):
        """Starts the background processing thread."""
        if not self.file_list:
             messagebox.showerror("错误", "请先添加要处理的文件！")
             return
        if self.processing_thread and self.processing_thread.is_alive():
            messagebox.showwarning("提示", "一个处理任务已经在运行中。")
            return

        # Read settings
        whisper_model_name = self.selected_model_var.get()
        whisper_lang = self.language_var.get().strip() or None
        device_choice = self.device_var.get()
        refine = self.refine_var.get()
        target_language = self.target_lang_var.get().strip()
        api_key = self.api_key_var.get().strip()
        api_base = self.api_base_url_var.get().strip()
        api_model = self.api_model_name_var.get().strip()
        self.update_concurrency_setting()
        style_config_data = {
            "style_default": {**self.config.get("style_default", DEFAULT_STYLE_DEFAULTS),"fontsize": self.style_default_fontsize_var.get(),"primary_colour": self.style_default_color_var.get()},
            "style_translated": {**self.config.get("style_translated", TRANSLATED_STYLE_DEFAULTS),"fontsize": self.style_translated_fontsize_var.get(),"primary_colour": self.style_translated_color_var.get()}
        }

        # Validations
        if refine and not openai_available: messagebox.showerror("配置错误", "`openai` 库未安装或不可用。"); return
        if refine:
            if not api_key: messagebox.showerror("配置错误", "未提供 API Key！"); return
            if not api_base: messagebox.showerror("配置错误", "未提供 API Base URL！"); return
            if not api_model: messagebox.showerror("配置错误", "未提供 API 模型名称！"); return
            if not target_language: messagebox.showerror("配置错误", "未指定目标语言！"); return

        # Determine device
        try:
            device = "cuda" if device_choice == "自动检测" and torch.cuda.is_available() else ("cpu" if device_choice == "自动检测" else device_choice)
            if device == "cuda" and not torch.cuda.is_available():
                 messagebox.showwarning("设备警告", "请求 CUDA 但不可用，将回退到 CPU。")
                 device = "cpu"
                 self.device_var.set("cpu")
        except Exception as e_device: messagebox.showerror("设备错误", f"检测设备时出错: {e_device}"); return

        # --- Start Processing ---
        self.stop_event.clear()
        self.disable_controls()
        files_to_process = self.file_list[:]
        self.progressbar['maximum'] = len(files_to_process)
        self.progressbar['value'] = 0
        self.log_area_clear()
        self.log_append(f"开始批处理 {len(files_to_process)} 个文件...")
        self.log_append(f"设置: Whisper模型={whisper_model_name}, 语言={whisper_lang if whisper_lang else '自动检测'}, 设备={device}")
        if refine: self.log_append(f"API设置: 双语={refine}, 目标={target_language}, Endpoint={api_base}, 模型={api_model}, 并发={MAX_CONCURRENT_REQUESTS}")
        else: self.log_append("API设置: 未启用")

        self.processing_thread = threading.Thread(
            target=process_video_thread,
            args=(files_to_process, whisper_model_name, whisper_lang, device, self.progress_queue, refine, target_language, api_key, api_base, api_model, style_config_data, self.stop_event),
            daemon=True
        )
        self.processing_thread.start()
        self.root.after(100, self.check_queue) # Start queue checker

    def check_queue(self):
        """Checks the progress queue and updates the GUI."""
        try:
            while True:
                message = self.progress_queue.get_nowait()
                if isinstance(message, tuple) and message[0] == "FILE_COMPLETE":
                    self.progressbar['value'] = message[1]
                elif message == "PROCESS_COMPLETE":
                    self.log_append("\n--- 批处理完成！---")
                    self.progressbar['value'] = self.progressbar['maximum']
                    self.enable_controls()
                    messagebox.showinfo("完成", "所有文件处理完成！")
                    self.processing_thread = None
                    return
                elif message == "PROCESS_FAILED":
                    self.log_append("\n--- 处理过程中发生错误！---")
                    self.enable_controls()
                    messagebox.showerror("失败", "处理过程中发生错误！请检查日志。")
                    self.processing_thread = None
                    return
                elif message == "PROCESS_STOPPED":
                    self.log_append("\n--- 处理已停止。---")
                    self.enable_controls()
                    messagebox.showinfo("已停止", "处理已被用户停止。")
                    self.processing_thread = None
                    return
                else:
                    self.log_append(str(message))
        except queue.Empty:
            if self.processing_thread is not None and self.processing_thread.is_alive():
                self.root.after(100, self.check_queue) # Schedule next check

    def update_control_states(self):
        """Updates the state of buttons based on the file list and processing state."""
        is_processing = self.processing_thread and self.processing_thread.is_alive()
        has_files = bool(self.file_list)
        stop_requested = self.stop_event.is_set()

        # Start Button
        start_state = tk.NORMAL if has_files and not is_processing else tk.DISABLED
        if hasattr(self, 'start_button'): self.start_button.config(state=start_state)

        # Stop Button
        stop_state = tk.NORMAL if is_processing and not stop_requested else tk.DISABLED
        if hasattr(self, 'stop_button'): self.stop_button.config(state=stop_state)

        # Restart Button
        restart_state = tk.NORMAL if not is_processing or stop_requested else tk.DISABLED
        if hasattr(self, 'restart_button'): self.restart_button.config(state=restart_state)

        # File List Buttons
        list_btn_state = tk.NORMAL if has_files and not is_processing else tk.DISABLED
        select_btn_state = tk.NORMAL if has_files and not is_processing else tk.DISABLED
        clear_btn_state = tk.NORMAL if has_files and not is_processing else tk.DISABLED
        if hasattr(self, 'remove_files_button'): self.remove_files_button.config(state=list_btn_state)
        if hasattr(self, 'select_all_button'): self.select_all_button.config(state=select_btn_state)
        if hasattr(self, 'clear_all_button'): self.clear_all_button.config(state=clear_btn_state)

        # Add/Path Buttons
        add_path_state = tk.NORMAL if not is_processing else tk.DISABLED
        if hasattr(self, 'add_files_button'): self.add_files_button.config(state=add_path_state)
        if hasattr(self, 'go_to_path_button'): self.go_to_path_button.config(state=add_path_state)
        if hasattr(self, 'path_entry'): self.path_entry.config(state=add_path_state)

        # Settings Tabs
        notebook_state = "normal" if not is_processing else "disabled"
        try:
             if hasattr(self, 'settings_notebook') and self.settings_notebook.winfo_exists():
                 for tab_id in self.settings_notebook.tabs():
                     self.settings_notebook.tab(tab_id, state=notebook_state)
        except tk.TclError: pass # Ignore if notebook not fully ready


    def disable_controls(self):
        """Disables relevant GUI elements during processing."""
        self.update_control_states()

    def enable_controls(self):
        """Enables GUI elements after processing."""
        self.stop_event.clear()
        self.update_control_states()
        self.toggle_api_options() # Re-apply enable/disable based on checkbox

    def log_append(self, message):
        """Appends a message to the log area safely."""
        if hasattr(self, 'log_area') and self.log_area and self.log_area.winfo_exists():
            try:
                self.log_area.config(state=tk.NORMAL)
                self.log_area.insert(tk.END, str(message) + "\n")
                self.log_area.see(tk.END)
                self.log_area.config(state=tk.DISABLED)
                if hasattr(self, 'root') and self.root.winfo_exists(): # Update only if root exists
                    self.root.update_idletasks()
            except tk.TclError as e:
                 print(f"Log append failed (widget likely destroyed): {e}")

    def log_area_clear(self):
        """Clears the log area."""
        if hasattr(self, 'log_area') and self.log_area and self.log_area.winfo_exists():
            try:
                self.log_area.config(state=tk.NORMAL)
                self.log_area.delete(1.0, tk.END)
                self.log_area.config(state=tk.DISABLED)
            except tk.TclError as e:
                 print(f"Log clear failed (widget likely destroyed): {e}")

# --- End of SubtitleApp Class ---


# --- Main Execution ---
if __name__ == "__main__":
    root = None
    applied_initial_theme = "clam" # Default fallback theme name

    # --- 加载配置以获取保存的主题 ---
    # Load config *before* creating the root window to get the desired theme
    # This allows setting the initial theme correctly.
    config = load_config()
    saved_theme = config.get("selected_theme", "clam") # Use loaded theme or default 'clam'

    # --- 主题应用逻辑 ---
    if use_themes:
        try:
            print("正在检查可用的 ttk 主题...")
            # Try to create a temporary root with the SAVED theme first
            # This helps verify if the saved theme is actually usable
            temp_root = ThemedTk(theme=saved_theme)
            temp_root.withdraw()
            available_themes = sorted(temp_root.get_themes()) # Get sorted list
            # Check which theme was *actually* applied by ThemedTk constructor
            # It might fallback if 'saved_theme' was invalid
            current_theme_on_temp = temp_root.current_theme
            temp_root.destroy()
            print(f"可用的 ttk 主题: {available_themes}")

            # Determine the theme to actually use for the main window
            initial_theme_to_use = "clam" # Start with fallback
            if saved_theme in available_themes:
                initial_theme_to_use = saved_theme # Use saved if valid
            elif current_theme_on_temp in available_themes:
                 initial_theme_to_use = current_theme_on_temp # Use the one ThemedTk fell back to
                 print(f"警告: 保存的主题 '{saved_theme}' 可能无效或不可用，使用 ThemedTk 回退的主题 '{initial_theme_to_use}'。")
                 config["selected_theme"] = initial_theme_to_use # Correct config for consistency
            elif available_themes:
                initial_theme_to_use = available_themes[0] # Fallback to first available in list
                print(f"警告: 保存的主题 '{saved_theme}' 不可用，将使用第一个可用主题 '{initial_theme_to_use}'。")
                config["selected_theme"] = initial_theme_to_use # Correct config
            else:
                # No themes available at all, but ThemedTk didn't error? Use 'clam'
                initial_theme_to_use = "clam"
                print("警告: 未找到可用主题，尝试使用 'clam'。")
                config["selected_theme"] = initial_theme_to_use # Correct config

            # --- 创建主窗口 ---
            print(f"尝试应用初始主题: {initial_theme_to_use}")
            # Create the main window WITH the determined initial theme
            root = ThemedTk(theme=initial_theme_to_use)
            applied_initial_theme = root.current_theme # Record the theme that was actually set
            print(f"已应用初始主题: {applied_initial_theme}")

        except tk.TclError as e:
            print(f"警告: 应用 ttk 主题 '{saved_theme}' 时 Tcl 错误 ({e}), 使用默认 Tk 主题。")
            root = tk.Tk()
            use_themes = False # Disable theme features if ThemedTk fails
        except Exception as e:
             print(f"应用 ttkthemes 主题时发生未知错误: {e}")
             traceback.print_exc()
             root = tk.Tk()
             use_themes = False # Disable theme features
    else:
        # If use_themes is False (due to import error or config)
        print("状态: 未配置使用 ttkthemes，创建标准 Tk 窗口。")
        root = tk.Tk()
    # --- 主题应用结束 ---

    # 确保 root 窗口已成功创建
    if root:
        try:
            # Pass the already loaded (and potentially corrected) config to the app
            app = SubtitleApp(root) # SubtitleApp now uses self.config

            # --- 同步 GUI 变量与实际应用的主题 ---
            # Ensure the theme combobox variable reflects the theme that was actually applied
            # This needs to happen AFTER app = SubtitleApp(root) so app.selected_theme_var exists
            if use_themes and hasattr(app, 'selected_theme_var') and hasattr(app, 'available_themes'):
                 if applied_initial_theme in app.available_themes:
                     app.selected_theme_var.set(applied_initial_theme)
                 elif app.available_themes: # If applied was somehow not in list, set to first
                      app.selected_theme_var.set(app.available_themes[0])
                 else:
                      # If no themes are available, disable the combobox if it exists
                      if hasattr(app, 'theme_combobox'):
                         app.theme_combobox.config(state=tk.DISABLED)

            root.mainloop()
        except Exception as main_err:
            # Catch potential errors during app initialization or mainloop start
            print(f"!!! 应用程序运行时发生致命错误: {main_err} !!!")
            traceback.print_exc()
            try: # Try to show an error message box if possible
                 messagebox.showerror("运行时错误", f"应用程序遇到严重错误，可能需要关闭。\n\n错误: {main_err}\n\n请查看控制台输出获取详细信息。")
            except:
                 pass # Avoid further errors if messagebox itself fails
    else:
        print("!!! 致命错误: 无法创建应用程序主窗口！!!!")
        try:
            messagebox.showerror("致命错误", "无法创建应用程序主窗口！请检查 Tkinter 安装和环境。")
        except:
            pass

# --- END OF FILE subtitle_app.py --- (End of the specific block)